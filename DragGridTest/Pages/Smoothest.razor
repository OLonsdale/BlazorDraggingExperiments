<!--suppress CssUnresolvedCustomProperty -->
@page "/"
@implements IDisposable
@inject IJSRuntime JS

<style>
    table {
        border-collapse: collapse;
        table-layout: fixed;
    }

    th, td {
        border: 1px solid #d0d0d0;
        padding: 0;
        box-sizing: border-box;
    }

    thead th {
        background: #f6f8fa;
        font-weight: 600;
        font-size: .9rem;
    }

    .container {
        width: 95vw;
        overflow: auto;
    }

    .machine-col {
        white-space: nowrap;
        padding: 0 .5rem;
    }

    .action-col {
        text-align: center;
    }

    .track-cell {
        padding: 0;
        overflow: hidden;
    }

    .lane {
        position: relative;
        height: var(--lane-h);
        width: 100%;
        user-select: none;
        -webkit-user-drag: none;
        touch-action: none;
        overflow: hidden;
    }

    .bar {
        position: absolute;
        height: var(--bar-h);
        box-sizing: border-box;
        cursor: grab;
        will-change: transform;
        display: flex;
        align-items: center;
        padding: 0 10px;
        overflow: hidden;
        z-index: 1;
        border-radius: 4px;
    }

    .bar:active {
        cursor: grabbing;
    }

    .bar.preview {
        outline: 2px dashed #7aa7ff;
        pointer-events: none;
        display: none;
        z-index: 3;
    }

    .bar.dragging {
        pointer-events: none;
        visibility: hidden;
    }

    .bar .label {
        pointer-events: none;
        user-select: none;
        font: 600 12px/1.1 system-ui;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        width: 100%;
    }

    .handle {
        position: absolute;
        top: 0;
        width: 10px;
        height: 100%;
        cursor: ew-resize;
        z-index: 2;
    }

    .handle.left {
        left: 0;
    }

    .handle.right {
        right: 0;
    }

    table, th, td {
        -webkit-user-drag: none;
        user-select: none;
    }

    .timeline-head {
        padding: 0;
    }

    .ruler {
        display: flex;
    }

    .ruler.days .day {
        text-align: center;
        border-left: 1px solid #e5e5e5;
    }

    .ruler.hours .hour {
        text-align: center;
        border-left: 1px dashed #eee;
        font-size: .85rem;
    }

    .ruler.mins-bg {
        height: 20px;
        position: relative;
        background: repeating-linear-gradient(to right, #ddd 0, #ddd 1px, transparent 1px var(--slot-w)),
        repeating-linear-gradient(to right, #bbb 0, #bbb 1px, transparent 1px var(--hour-w));
    }
</style>

<InputDate @bind-Value="Range.StartDate"/> Range Start |
<InputDate @bind-Value="Range.EndDateInclusive"/> Range End |
<input type="time" @bind="WorkingHours.Start"/> start |
<input type="time" @bind="WorkingHours.End"/> end |
<InputCheckbox @bind-Value="showHours"/> hours |
<InputCheckbox @bind-Value="usershowmins"/> mins |
<InputNumber @onmousewheel="WheelEv" @bind-Value="dayWidth"/> day width |
<InputNumber @bind-Value="snapToMins" min="1" step="1"/> snap (mins)

<div
    style="position:sticky; top:0; z-index:10; background:#fff9; backdrop-filter:saturate(150%) blur(4px); font:12px/1.2 system-ui; padding:.25rem .5rem; border:1px solid #ddd; width:max-content; border-radius:6px;">
    <b>FPS:</b> @_latest.Fps
    &nbsp;|&nbsp; <b>long tasks:</b> @_latest.LongTasks
    &nbsp;|&nbsp; <b>max:</b> @_latest.Longest.ToString("0.0")ms
    &nbsp;|&nbsp; <b>pointermove/s:</b> @_latest.PointerMoves * 4
    &nbsp;|&nbsp; <b>lane DOM:</b> @_latest.DomNodes
    &nbsp;|&nbsp; <b>bars:</b> @machines.Sum(x => x.Routings.Count)
    &nbsp;|&nbsp; <b>renders:</b> @renderCount
    &nbsp;|&nbsp; <b>max overlap:</b> @_globalLevels
</div>

<div class="container">
    <table draggable="false"
           @ondragstart:preventDefault
           style="
               --day-w:@($"{dayWidth}px");
           --days:@DaysCount;
           --machine-w:180px;
           --action-w:56px;
           --left-w: calc(var(--machine-w) + var(--action-w));
           --mins-per-day:@(Math.Max(1, MinutesPerDay).ToString("0"));
           --px-per-min: calc(var(--day-w) / var(--mins-per-day));
           --hour-w: calc(var(--px-per-min) * 60);
           --slot-w: calc(var(--px-per-min) * @MinutesPerSlot);
           --bar-h:@($"{BarHeightPx}px");
           --lane-h:@($"{LaneHeightPx}px");
           width: calc(var(--left-w) + (var(--day-w) * var(--days)));
           ">
        <colgroup>
            <col class="machine-col" style="width:var(--machine-w)"/>
            <col class="action-col" style="width:var(--action-w)"/>
            <col class="timeline-col" style="width:calc(var(--day-w) * var(--days))"/>
        </colgroup>

        <thead>
        <tr>
            <th class="machine-col" rowspan="@HeaderRowSpan">Machine</th>
            <th class="action-col" rowspan="@HeaderRowSpan">Action</th>
            <th class="timeline-head">
                <div class="ruler days" style="width:calc(var(--day-w) * var(--days))">
                    @foreach (var date in Range.DaysInclusive)
                    {
                        <div class="day" style="width:@($"{dayWidth}px")">@date.Day</div>
                    }
                </div>

                @if (ShowHoursRow)
                {
                    <div class="ruler hours" style="width:calc(var(--day-w) * var(--days))">
                        @foreach (var _ in Range.DaysInclusive)
                        {
                            @foreach (var h in WorkingHours.Hours)
                            {
                                <div class="hour" style="width:calc(var(--px-per-min) * 60)">@h.ToString("HH")</div>
                            }
                        }
                    </div>
                }

                @if (ShowMinsRow)
                {
                    <div class="ruler mins-bg" style="height: 10px; width:calc(var(--day-w) * var(--days));"></div>
                }
            </th>
        </tr>
        </thead>

        <tbody>
        <Virtualize Items="machines" Context="m">
            <tr>
                <td class="machine-col">@m.Name</td>
                <td class="action-col">
                    <button @onclick="() => OnMachineAction(m)">â‹¯</button>
                </td>

                <td class="track-cell">
                    <div class="lane"
                         data-lane-idx="@m.Index"
                         @ref="m.LaneRef"
                         @onpointermove="LaneMove"
                         @onpointerup="LaneUp"
                         @onpointercancel="LaneCancel">

                        @foreach (var r in m.Routings)
                        {
                            var left = OffsetPx(r.TimeSpan.Start);
                            var width = WidthPx(r.TimeSpan.Start, r.TimeSpan.EndExclusive);
                            if (width > 0)
                            {
                                var top = TopPxForLevel(r.Level);
                                <div class="bar @(drag?.Routing == r ? "dragging" : "")"
                                     style="@($"top:{top}px; transform:translateX({left}px); width:{width}px; background:{r.Bg}; border:1px solid {r.Border}; color:{r.Text}")"
                                     @onpointerdown="(e) => BarDown(e, m, r, left, width)">

                                    <div class="handle left"
                                         @onpointerdown="(e) => ResizeStartDown(e, m, r, left, width)"
                                         @onpointerdown:stopPropagation></div>

                                    <div class="label">@r.Label</div>

                                    <div class="handle right"
                                         @onpointerdown="(e) => ResizeEndDown(e, m, r, left, width)"
                                         @onpointerdown:stopPropagation></div>
                                </div>
                            }
                        }

                        <div class="bar preview" @ref="m.PreviewRef">
                            <div class="label"></div>
                        </div>
                    </div>
                </td>
            </tr>
        </Virtualize>
        </tbody>
    </table>
</div>

@code {
    const int MinutesPerSlot = 15;

    const int BarHeightPx = 32;
    const int BarGapPx = 3;
    const int LanePadTopPx = 2;
    const int LanePadBottomPx = 2;

    int dayWidth = 1000;
    int snapToMins = 5;

    bool showHours = true;
    bool usershowmins = true;

    bool ShowHoursRow => showHours && dayWidth >= 200;
    bool ShowMinsRow => ShowHoursRow && usershowmins;
    int HeaderRowSpan => 1 + (ShowHoursRow ? 1 : 0) + (ShowMinsRow ? 1 : 0);

    DateRange Range = new();
    TimeRange WorkingHours = new() { Start = new TimeOnly(8, 0), End = new TimeOnly(17, 0) };

    int renderCount = 0;

    protected override bool ShouldRender()
    {
        renderCount++;
        return true;
    }

    List<Machine> machines =
    [
        new("Lathe"),
        new("Milling Machine"),
        new("Surface Grinder"),
        new("CNC Router"),
        new("Hydraulic Press"),
        new("Injection Molder"),
        new("Die Cutter"),
        new("Plasma Cutter"),
        new("Laser Engraver"),
        new("3D Printer"),
        new("CNC Turning Center"),
        new("Drill Press"),
        new("Band Saw"),
        new("Waterjet Cutter"),
        new("Gear Hobbing Machine"),
        new("Welding Station"),
        new("Sheet Metal Brake"),
        new("Punch Press"),
        new("Vertical Machining Center"),
        new("Horizontal Boring Mill")
    ];

    int DaysCount => Math.Max(1, Range.DaysCount);
    double MinutesPerDay => Math.Max(0, (WorkingHours.End - WorkingHours.Start).TotalMinutes);
    double PxPerMinute => dayWidth / Math.Max(1.0, MinutesPerDay);
    double LaneWidthPx => dayWidth * DaysCount;

    int _globalLevels = 1;
    int LaneHeightPx => LanePadTopPx + LanePadBottomPx + (_globalLevels * (BarHeightPx + BarGapPx));
    int TopPxForLevel(int level) => LanePadTopPx + (level * (BarHeightPx + BarGapPx));

    void OnMachineAction(Machine m)
    {
    }

    class Routing
    {
        public Guid Id = Guid.NewGuid();
        public int Sequence;

        public string Name = "";
        public string MoNumber = "";

        public string Bg = "#e8f0ff";
        public string Border = "#9bbcff";
        public string Text = "#1b2a4a";

        public int Level;
        public int PreferredLevel = -1;

        public DateRange TimeSpan = new();

        public string Label =>
            string.IsNullOrWhiteSpace(Name) && string.IsNullOrWhiteSpace(MoNumber)
                ? $"{Sequence:00}"
                : $"{MoNumber} {Name}".Trim();
    }

    class DateRange
    {
        public DateTime Start { get; set; }
        public DateTime EndExclusive { get; set; }

        public DateTime StartDate
        {
            get => Start.Date;
            set
            {
                Start = value.Date;
                if (EndExclusive <= Start) EndExclusive = Start.AddDays(1);
            }
        }

        public DateTime EndDateInclusive
        {
            get => EndExclusive.Date.AddDays(-1);
            set
            {
                EndExclusive = value.Date.AddDays(1);
                if (EndExclusive <= Start) EndExclusive = Start.AddDays(1);
            }
        }

        public int DaysCount => (int)Math.Max(1, (EndExclusive.Date - Start.Date).TotalDays);

        public IEnumerable<DateTime> DaysInclusive
        {
            get
            {
                var last = EndExclusive.Date.AddDays(-1);
                for (var d = Start.Date; d <= last; d = d.AddDays(1))
                    yield return d;
            }
        }
    }

    class TimeRange
    {
        public TimeOnly Start;
        public TimeOnly End;

        public IEnumerable<TimeOnly> Hours
        {
            get
            {
                if (End <= Start) yield break;

                var first = new TimeOnly(Start.Hour, 0);
                if (first < Start) first = first.AddHours(1);

                for (var h = first; h < End; h = h.AddHours(1))
                    yield return h;
            }
        }
    }

    static Routing CreateRandomRouting(DateRange range, TimeRange hours, int seq, int minDurationMin = 30, int maxDurationMin = 240)
    {
        var rnd = Random.Shared;

        var dayCount = (range.EndExclusive.Date - range.Start.Date).Days;
        var day = range.Start.Date.AddDays(rnd.Next(Math.Max(1, dayCount)));

        var workingMins = (int)Math.Max(0, (hours.End - hours.Start).TotalMinutes);
        if (workingMins <= 0)
            return new Routing { Sequence = seq, TimeSpan = new DateRange { Start = day, EndExclusive = day.AddMinutes(1) } };

        var duration = Math.Clamp(rnd.Next(minDurationMin, maxDurationMin + 1), 1, workingMins);
        var latestStart = Math.Max(0, workingMins - duration);
        var startOffset = rnd.Next(latestStart + 1);

        var start = day.AddHours(hours.Start.Hour).AddMinutes(hours.Start.Minute + startOffset);
        var end = start.AddMinutes(duration);

        var verbs = new[] { "Turn", "Mill", "Drill", "Tap", "Grind", "Cut", "Weld", "Inspect", "Assemble", "Pack" };
        var parts = new[] { "Frame", "Shaft", "Bracket", "Housing", "Plate", "Rotor", "Stator", "Base", "Arm", "Cover" };

        var hues = new[] { ("#e8f0ff", "#9bbcff", "#1b2a4a"), ("#e8fff3", "#86d8b8", "#0f3b2c"), ("#fff1e8", "#ffb17a", "#4a2a1b"), ("#f3e8ff", "#c09bff", "#2f1b4a") };
        var c = hues[rnd.Next(hues.Length)];

        return new Routing
        {
            Sequence = seq,
            MoNumber = $"MO{rnd.Next(100000, 999999)}",
            Name = $"{verbs[rnd.Next(verbs.Length)]} {parts[rnd.Next(parts.Length)]}",
            Bg = c.Item1,
            Border = c.Item2,
            Text = c.Item3,
            TimeSpan = new DateRange { Start = start, EndExclusive = end }
        };
    }

    void RecomputeLevels()
    {
        _globalLevels = 1;

        foreach (var m in machines)
        {
            AssignLevelsWithPreferences(m.Routings);

            var max = m.Routings.Count == 0 ? 1 : (m.Routings.Max(r => r.Level) + 1);
            _globalLevels = Math.Max(_globalLevels, max);
        }
    }

    static void AssignLevelsWithPreferences(List<Routing> routings)
    {
        routings.Sort((a, b) => a.TimeSpan.Start.CompareTo(b.TimeSpan.Start));

        var levelEnds = new List<DateTime>();

        foreach (var r in routings)
        {
            var s = r.TimeSpan.Start;
            var e = r.TimeSpan.EndExclusive;

            var pref = r.PreferredLevel < 0 ? r.Level : r.PreferredLevel;
            if (pref < 0) pref = 0;

            while (levelEnds.Count <= pref)
                levelEnds.Add(DateTime.MinValue);

            if (levelEnds[pref] <= s)
            {
                r.Level = pref;
                levelEnds[pref] = e;
                continue;
            }

            var placed = false;
            for (var i = 0; i < levelEnds.Count; i++)
            {
                if (levelEnds[i] <= s)
                {
                    r.Level = i;
                    levelEnds[i] = e;
                    placed = true;
                    break;
                }
            }

            if (!placed)
            {
                r.Level = levelEnds.Count;
                levelEnds.Add(e);
            }
        }
    }

    static bool Overlaps(DateTime aStart, DateTime aEnd, DateTime bStart, DateTime bEnd) =>
        aStart < bEnd && bStart < aEnd;

    int DesiredLevelFromOffsetY(double offsetY)
    {
        var slot = BarHeightPx + BarGapPx;
        var raw = (int)Math.Floor((offsetY - LanePadTopPx) / slot);
        return Math.Clamp(raw, 0, Math.Max(0, _globalLevels - 1));
    }

    int FindBestLevel(Machine target, DateTime s, DateTime e, Routing moving, int preferredLevel)
    {
        var max = Math.Max(1, _globalLevels);

        bool LevelOk(int level)
        {
            foreach (var r in target.Routings)
            {
                if (ReferenceEquals(r, moving)) continue;
                if (r.Level != level) continue;
                if (Overlaps(s, e, r.TimeSpan.Start, r.TimeSpan.EndExclusive)) return false;
            }

            return true;
        }

        if (preferredLevel >= 0 && preferredLevel < max && LevelOk(preferredLevel))
            return preferredLevel;

        for (var level = 0; level < max; level++)
            if (LevelOk(level))
                return level;

        return max - 1;
    }

    protected override void OnInitialized()
    {
        var start = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1);

        Range = new() { Start = start, EndExclusive = start.AddMonths(3) };

        for (var i = 0; i < machines.Count; i++)
            machines[i].Index = i;

        foreach (var m in machines)
            m.Routings = Enumerable.Range(1, 20).Select(seq => CreateRandomRouting(Range, WorkingHours, seq)).ToList();

        RecomputeLevels();
    }

    class Machine(string name)
    {
        public int Index { get; set; }
        public string Name { get; } = name;
        public List<Routing> Routings = [];
        public ElementReference LaneRef;
        public ElementReference PreviewRef;
    }

    DateTime DayWorkingStart(DateTime d) => d.Date.AddHours(WorkingHours.Start.Hour).AddMinutes(WorkingHours.Start.Minute);

    double MinutesSinceRangeStart(DateTime t)
    {
        var dayOffset = (t.Date - Range.Start.Date).TotalDays;
        var inDay = (t - DayWorkingStart(t)).TotalMinutes;
        var inDayClamped = Math.Clamp(inDay, 0, MinutesPerDay);
        return dayOffset * MinutesPerDay + inDayClamped;
    }

    double OffsetPx(DateTime t) => Math.Clamp(MinutesSinceRangeStart(t) * PxPerMinute, 0, LaneWidthPx);

    double WidthPx(DateTime s, DateTime e)
    {
        var left = MinutesSinceRangeStart(s) * PxPerMinute;
        var right = MinutesSinceRangeStart(e) * PxPerMinute;
        var w = right - left;
        return w <= 0 ? 0 : Math.Min(w, LaneWidthPx - Math.Clamp(left, 0, LaneWidthPx));
    }

    DateTime TimeFromPx(double x)
    {
        var mins = Math.Clamp(x, 0, LaneWidthPx) / PxPerMinute;
        var day = Math.Floor(mins / Math.Max(1.0, MinutesPerDay));
        var inDay = mins - day * MinutesPerDay;
        var baseDay = Range.Start.Date.AddDays(day);
        return DayWorkingStart(baseDay).AddMinutes(inDay);
    }

    double SnapPx(double px)
    {
        var snap = Math.Max(1, snapToMins);
        var snapPx = PxPerMinute * snap;
        return Math.Round(px / snapPx) * snapPx;
    }

    double ClampLeft(double leftPx, double widthPx) => Math.Clamp(leftPx, 0, LaneWidthPx - widthPx);

    double ClampWidth(double widthPx)
    {
        var minPx = Math.Max(1.0, PxPerMinute * Math.Max(1, snapToMins));
        return Math.Clamp(widthPx, minPx, LaneWidthPx);
    }

    enum DragMode
    {
        Move,
        ResizeStart,
        ResizeEnd
    }

    record DragState(
        Machine Origin,
        Routing Routing,
        long PointerId,
        DragMode Mode,
        double GrabOffsetPx,
        double FixedLeftPx,
        double FixedRightPx,
        int StartLevel
    );

    sealed class LaneHit
    {
        public int idx { get; set; }
        public double offsetX { get; set; }
        public double offsetY { get; set; }
    }

    DragState? drag;
    int _lastHitIdx = -1;
    Machine? _previewMachine;
    IJSObjectReference? _ui;

    async Task ShowPreviewAsync(Machine m, double leftPx, double widthPx, int topPx, Routing r)
    {
        if (_ui is null) return;

        if (_previewMachine is not null && _previewMachine != m)
            await _ui.InvokeVoidAsync("hidePreview", _previewMachine.PreviewRef);

        _previewMachine = m;
        await _ui.InvokeVoidAsync("showPreview", m.PreviewRef, leftPx, widthPx, topPx, r.Label, r.Bg, r.Border, r.Text);
    }

    async Task HidePreviewAsync(Machine m)
    {
        if (_ui is null) return;
        await _ui.InvokeVoidAsync("hidePreview", m.PreviewRef);
        if (_previewMachine == m) _previewMachine = null;
    }

    async Task<LaneHit?> HitLaneAsync(PointerEventArgs e)
    {
        if (_ui is null) return null;
        var hit = await _ui.InvokeAsync<LaneHit>("laneHit", e.ClientX, e.ClientY);
        if (hit.idx < 0 || hit.idx >= machines.Count) return null;
        return hit;
    }

    Task BarDown(PointerEventArgs e, Machine m, Routing r, double leftPx, double widthPx) => StartDrag(e, m, r, leftPx, widthPx, DragMode.Move);
    Task ResizeStartDown(PointerEventArgs e, Machine m, Routing r, double leftPx, double widthPx) => StartDrag(e, m, r, leftPx, widthPx, DragMode.ResizeStart);
    Task ResizeEndDown(PointerEventArgs e, Machine m, Routing r, double leftPx, double widthPx) => StartDrag(e, m, r, leftPx, widthPx, DragMode.ResizeEnd);

    async Task StartDrag(PointerEventArgs e, Machine m, Routing r, double leftPx, double widthPx, DragMode mode)
    {
        var fixedLeft = leftPx;
        var fixedRight = leftPx + widthPx;
        var grab = mode == DragMode.Move ? e.OffsetX : 0;

        r.PreferredLevel = r.Level;

        drag = new(m, r, e.PointerId, mode, grab, fixedLeft, fixedRight, r.Level);
        _lastHitIdx = m.Index;

        if (_ui is not null)
            await _ui.InvokeVoidAsync("capture", m.LaneRef, e.PointerId);

        await ShowPreviewAsync(m, leftPx, widthPx, TopPxForLevel(r.Level), r);
        StateHasChanged();
    }

    Task LaneMove(PointerEventArgs e) => LaneMoveImpl(e);

    async Task LaneMoveImpl(PointerEventArgs e)
    {
        if (drag is null) return;

        var hit = await HitLaneAsync(e);
        if (hit is null) return;

        _lastHitIdx = hit.idx;
        var target = machines[_lastHitIdx];

        double left;
        double width;

        if (drag.Mode == DragMode.Move)
        {
            var proposedLeft = hit.offsetX - drag.GrabOffsetPx;
            width = WidthPx(drag.Routing.TimeSpan.Start, drag.Routing.TimeSpan.EndExclusive);
            left = ClampLeft(SnapPx(proposedLeft), width);
        }
        else if (drag.Mode == DragMode.ResizeStart)
        {
            left = SnapPx(hit.offsetX);
            var right = drag.FixedRightPx;
            width = ClampWidth(right - left);
            left = ClampLeft(left, width);
        }
        else
        {
            left = drag.FixedLeftPx;
            var right = SnapPx(hit.offsetX);
            width = ClampWidth(right - left);
            left = ClampLeft(left, width);
        }

        var s = TimeFromPx(left);
        var end = TimeFromPx(left + width);

        var desiredLevel = DesiredLevelFromOffsetY(hit.offsetY);
        var level = FindBestLevel(target, s, end, drag.Routing, desiredLevel);
        var top = TopPxForLevel(level);

        await ShowPreviewAsync(target, left, width, top, drag.Routing);
    }

    Task LaneUp(PointerEventArgs e) => LaneUpImpl(e);

    async Task LaneUpImpl(PointerEventArgs e)
    {
        if (drag is null) return;

        var hit = await HitLaneAsync(e);
        if (hit is not null) _lastHitIdx = hit.idx;
        if (_lastHitIdx < 0 || _lastHitIdx >= machines.Count) _lastHitIdx = drag.Origin.Index;

        var target = machines[_lastHitIdx];

        double left;
        double width;

        if (drag.Mode == DragMode.Move)
        {
            var offsetX = hit?.offsetX ?? 0;
            var proposedLeft = offsetX - drag.GrabOffsetPx;
            width = WidthPx(drag.Routing.TimeSpan.Start, drag.Routing.TimeSpan.EndExclusive);
            left = ClampLeft(SnapPx(proposedLeft), width);
        }
        else if (drag.Mode == DragMode.ResizeStart)
        {
            var offsetX = hit?.offsetX ?? drag.FixedLeftPx;
            left = SnapPx(offsetX);
            var right = drag.FixedRightPx;
            width = ClampWidth(right - left);
            left = ClampLeft(left, width);
        }
        else
        {
            left = drag.FixedLeftPx;
            var offsetX = hit?.offsetX ?? drag.FixedRightPx;
            var right = SnapPx(offsetX);
            width = ClampWidth(right - left);
            left = ClampLeft(left, width);
        }

        var newStart = TimeFromPx(left);
        var newEnd = TimeFromPx(left + width);

        if (target != drag.Origin)
        {
            drag.Origin.Routings.Remove(drag.Routing);
            target.Routings.Add(drag.Routing);
        }

        drag.Routing.TimeSpan.Start = newStart;
        drag.Routing.TimeSpan.EndExclusive = newEnd;

        if (hit is not null)
            drag.Routing.PreferredLevel = DesiredLevelFromOffsetY(hit.offsetY);
        else
            drag.Routing.PreferredLevel = drag.StartLevel;

        RecomputeLevels();

        if (_ui is not null)
            await _ui.InvokeVoidAsync("release", drag.Origin.LaneRef, drag.PointerId);

        if (_previewMachine is not null)
            await HidePreviewAsync(_previewMachine);

        drag = null;
        _lastHitIdx = -1;
        StateHasChanged();
    }

    Task LaneCancel(PointerEventArgs e) => LaneCancelImpl(e);

    async Task LaneCancelImpl(PointerEventArgs e)
    {
        if (drag is null) return;

        drag.Routing.PreferredLevel = drag.StartLevel;

        if (_ui is not null)
            await _ui.InvokeVoidAsync("release", drag.Origin.LaneRef, drag.PointerId);

        if (_previewMachine is not null)
            await HidePreviewAsync(_previewMachine);

        drag = null;
        _lastHitIdx = -1;
        StateHasChanged();
    }

    void WheelEv(WheelEventArgs ev)
    {
        int v = ev.AltKey ? 100 : 10;
        dayWidth = Math.Clamp(dayWidth + (ev.DeltaY > 0 ? v : -v), 100, 4000);
    }

    System.Timers.Timer? _perfTimer;
    IJSObjectReference? _perf;
    PerfSnap _latest = new();

    record PerfSnap(double Fps = 0, int LongTasks = 0, double Longest = 0, int PointerMoves = 0, int DomNodes = 0);

    public class PerfDto
    {
        public double fps { get; set; }
        public int longTasks { get; set; }
        public double longest { get; set; }
        public int pmCount { get; set; }
        public int domNodes { get; set; }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        _ui = await JS.InvokeAsync<IJSObjectReference>("import", "./js/timeline-ui.js");

        _perf = await JS.InvokeAsync<IJSObjectReference>("import", "./js/perf.js");
        await _perf.InvokeVoidAsync("start", ".lane");

        _perfTimer = new System.Timers.Timer(250);
        var busy = 0;

        _perfTimer.Elapsed += async (_, __) =>
        {
            if (_perf is null) return;
            if (Interlocked.Exchange(ref busy, 1) == 1) return;

            try
            {
                var snap = await _perf.InvokeAsync<PerfDto>("snapshot", ".track-cell");
                _latest = new PerfSnap(snap.fps, snap.longTasks, snap.longest, snap.pmCount, snap.domNodes);
                await InvokeAsync(StateHasChanged);
            }
            finally
            {
                Interlocked.Exchange(ref busy, 0);
            }
        };

        _perfTimer.AutoReset = true;
        _perfTimer.Start();
    }

    public void Dispose()
    {
        _perfTimer?.Stop();
        _perfTimer?.Dispose();
        _ = _perf?.InvokeVoidAsync("stop");
        _ = _ui?.DisposeAsync();
        _ = _perf?.DisposeAsync();
    }

}
